---
phase: 01-infrastructure-hardening
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - backend/app/logging_config.py
  - backend/app/api/routes.py
  - backend/app/api/tools.py
  - backend/main.py
  - backend/app/rag/ingest.py
  - backend/requirements.txt
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - INFRA-04

must_haves:
  truths:
    - "Rulebook queries return in under 500ms on second call because ChromaDB initializes once as singleton"
    - "WebSocket connections that stop responding are cleaned up within 60 seconds"
    - "Backend logs are structured JSON lines with no print() statements remaining"
  artifacts:
    - path: "backend/app/logging_config.py"
      provides: "structlog configuration with dev/prod dual mode"
      contains: "setup_logging"
    - path: "backend/app/api/tools.py"
      provides: "ChromaDB lazy singleton and structured logging"
      contains: "_get_vector_db"
    - path: "backend/app/api/routes.py"
      provides: "WebSocket heartbeat connection manager and structured logging"
      contains: "ConnectionManager"
  key_links:
    - from: "backend/main.py"
      to: "backend/app/logging_config.py"
      via: "setup_logging() called during lifespan startup"
      pattern: "setup_logging"
    - from: "backend/app/api/tools.py"
      to: "backend/app/config.py"
      via: "ChromaDB singleton uses config constants"
      pattern: "from app.config import.*CHROMA_DB_PATH"
    - from: "backend/app/api/routes.py"
      to: "backend/app/config.py"
      via: "WebSocket heartbeat uses config intervals"
      pattern: "from app.config import.*WS_HEARTBEAT_INTERVAL"
---

<objective>
Add structured JSON logging, implement ChromaDB singleton, and add WebSocket heartbeat with stale connection cleanup.

Purpose: Replace all print() statements with structured logging for observability, eliminate per-call ChromaDB re-initialization for performance, and add WebSocket connection health management for reliability.
Output: New `backend/app/logging_config.py`, refactored `tools.py` with ChromaDB singleton, refactored `routes.py` with ConnectionManager heartbeat, updated `requirements.txt` with structlog.
</objective>

<execution_context>
@/Users/adityamurarka/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adityamurarka/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-hardening/01-RESEARCH.md
@.planning/phases/01-infrastructure-hardening/01-01-SUMMARY.md
@.planning/codebase/ARCHITECTURE.md

@backend/app/config.py
@backend/app/api/routes.py
@backend/app/api/tools.py
@backend/main.py
@backend/app/rag/ingest.py
@backend/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add structlog and replace all print() statements with structured logging</name>
  <files>backend/requirements.txt, backend/app/logging_config.py, backend/app/api/routes.py, backend/app/api/tools.py, backend/main.py, backend/app/rag/ingest.py</files>
  <action>
**Step 1: Install structlog**
Add `structlog` to `backend/requirements.txt`. Run `pip install structlog` to install.

**Step 2: Create backend/app/logging_config.py**
Create NEW file with `setup_logging()` function following the research pattern:
- Use `ENVIRONMENT` env var to detect dev vs production
- Dev mode: structlog ConsoleRenderer (pretty, colored output)
- Production mode: structlog JSONRenderer (machine-parseable lines)
- Configure shared processors: merge_contextvars, add_log_level, add_logger_name, TimeStamper(fmt="iso"), StackInfoRenderer, UnicodeDecoder
- Bridge stdlib logging through structlog so third-party library logs are also structured
- Silence noisy libraries: httpx, chromadb, sentence_transformers at WARNING level

**Step 3: Initialize logging at startup**
In `backend/main.py`, import and call `setup_logging()` at the top of the lifespan context manager (before any other startup work). This ensures all subsequent log calls use structured output.

**Step 4: Replace ALL print() statements**
Replace every print() call across the backend with appropriate structlog calls. Use `logger = structlog.get_logger()` at the top of each module.

Replacement patterns:
- `print("message")` -> `logger.info("descriptive.event.name")`
- `print(f"... {var}")` -> `logger.info("event.name", key=var)`
- `print(f"ERROR: ...")` -> `logger.error("event.name", error=str(e))`
- `print(f"DEBUG: ...")` -> `logger.debug("event.name", detail=val)`

Use dot-separated event names (e.g., "tool.executing", "agent.turn", "prefetch.starting", "chromadb.initializing").

Files and approximate print() counts:
- tools.py: ~15 calls (tool execution, results, errors)
- routes.py: ~17 calls (request handling, agent loop, errors)
- main.py: ~5 calls (prefetch loop status)
- ingest.py: ~11 calls (CLI script, migrate to structlog for consistency)

Do NOT touch `scripts/test_models.py` -- it is a standalone test script.

**Important:** After replacing print() calls, verify zero print() statements remain in the 4 target files (excluding any in string literals or comments).
  </action>
  <verify>
Run `cd /Users/adityamurarka/Desktop/F1-AI/backend && pip install structlog` succeeds.
Run `python -c "from app.logging_config import setup_logging; setup_logging(); print('Logging OK')"` succeeds.
Run `grep -n "^[^#]*\bprint(" backend/app/api/routes.py backend/app/api/tools.py backend/main.py backend/app/rag/ingest.py` returns zero matches (all print() replaced).
Run `python -c "import structlog; structlog.get_logger().info('test', key='value')"` produces structured output.
  </verify>
  <done>structlog is installed and configured. All 53 print() calls across routes.py, tools.py, main.py, and ingest.py are replaced with structured logger calls. setup_logging() is called during server startup. Dev mode shows pretty console output, production shows JSON lines.</done>
</task>

<task type="auto">
  <name>Task 2: Implement ChromaDB lazy singleton and WebSocket heartbeat connection manager</name>
  <files>backend/app/api/tools.py, backend/app/api/routes.py</files>
  <action>
**ChromaDB Singleton (in tools.py):**

Refactor `consult_rulebook()` tool to use a lazy singleton pattern:
1. Add module-level variables `_embeddings = None` and `_vector_db = None`
2. Create `_get_vector_db()` function that initializes on first call using `threading.Lock` for thread safety
3. Import CHROMA_DB_PATH, EMBEDDING_MODEL_NAME, RULEBOOK_TOP_K from app.config
4. The `consult_rulebook()` function calls `_get_vector_db()` instead of creating new instances each time
5. Log "chromadb.initializing" on first init and "chromadb.ready" when done
6. On subsequent calls, log "chromadb.query" with the search query at debug level

The lock prevents race conditions if two concurrent requests both trigger initialization. After initialization, the lock check is effectively free.

**WebSocket Connection Manager (in routes.py):**

Create a `ConnectionManager` class:
1. Tracks active connections per room in `dict[str, list[WebSocket]]`
2. Tracks last activity time per connection in `dict[int, float]` (id(ws) -> timestamp)
3. `connect(room, ws)` method: accept, register, record time
4. `disconnect(room, ws)` method: remove from tracking dicts
5. `heartbeat(ws)` coroutine: every WS_HEARTBEAT_INTERVAL seconds, sends `{"type": "ping"}` JSON. On send failure, breaks loop.
6. Log connections and disconnections with structured logging.

Replace the existing `_live_connections` dict usage with the ConnectionManager instance.

Update the WebSocket endpoint(s) to:
1. Use `manager.connect(room, ws)` on connection
2. Start `manager.heartbeat(ws)` as a background asyncio task
3. Use `manager.disconnect(room, ws)` in finally block on disconnect
4. Cancel the heartbeat task in finally block

Import WS_HEARTBEAT_INTERVAL, WS_STALE_TIMEOUT from app.config (created in Plan 01).

**Important:** The WebSocket endpoint currently at routes.py (around line 860-897) should be the primary target. Ensure the heartbeat ping is application-level JSON (not WebSocket protocol ping) since the client may not handle protocol pings.
  </action>
  <verify>
Run `cd /Users/adityamurarka/Desktop/F1-AI/backend && python -c "from app.api.tools import _get_vector_db; print('Singleton function exists')"` succeeds.
Run `grep -n "HuggingFaceEmbeddings\|Chroma(" backend/app/api/tools.py | grep -v "^.*#" | wc -l` returns exactly the singleton initialization lines (should be 2-3, not per-call).
Run `grep -n "class ConnectionManager" backend/app/api/routes.py` returns a match.
Run `grep -n "heartbeat" backend/app/api/routes.py` returns matches for the heartbeat method.
Run `cd /Users/adityamurarka/Desktop/F1-AI/backend && python -c "from app.api.routes import router; print('Routes OK')"` succeeds without errors.
  </verify>
  <done>ChromaDB initializes once via lazy singleton with thread-safe locking -- second consult_rulebook() call skips initialization entirely. WebSocket connections use ConnectionManager with heartbeat pings every 15 seconds and automatic cleanup of stale connections. Both use structured logging.</done>
</task>

</tasks>

<verification>
1. `grep -rn "^[^#]*\bprint(" backend/app/api/routes.py backend/app/api/tools.py backend/main.py backend/app/rag/ingest.py` returns zero matches
2. `python -c "from app.api.tools import _get_vector_db"` imports without error
3. `grep "class ConnectionManager" backend/app/api/routes.py` returns a match
4. `grep "structlog" backend/requirements.txt` returns a match
5. `cd backend && timeout 15 python -c "from app.logging_config import setup_logging; setup_logging(); from app.api.routes import router; print('All OK')"` succeeds
6. Zero print() statements remain in production code files
</verification>

<success_criteria>
- structlog installed and configured with dev/prod dual mode
- All 53 print() calls replaced with structured logger calls across 4 files
- ChromaDB uses lazy singleton pattern -- HuggingFaceEmbeddings and Chroma created once, not per tool call
- ConnectionManager class manages WebSocket connections with heartbeat pings
- Stale WebSocket connections are cleaned up automatically
- Backend starts and imports without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-hardening/01-02-SUMMARY.md`
</output>
